<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Come First Serve</title>
    <link rel="stylesheet" href="../../css/styleSub.css">
</head>

<body>
    <div class="progress"></div>

    <!--  navbar -->
    <div class="nav">
        <nav class="nav-bar">
            <a class="nav-link" href="../../index.html">Home</a>
            <a class="nav-link" href="../FCFS/FCFS.html">FCFS</a>
            <a class="nav-link" href="../SSTF/SSTF.html">SSTF</a>
            <a class="nav-link" href="../Scan/Scan.html">Scan</a>
            <a class="nav-link" href="../Look/Look.html">Look</a>
        </nav>
    </div>

    <div class="main">

        <!-- Heading + Content -->
        <div class="content">
            <div class="heading">
                <h1 id="h-fcfs">FIRST COME FIRST SERVE</h1>
            </div>
            <div class="algo-btn">
                <a class="algo-link" href="Simulator.html">Algorithm</a>
            </div>

            <div class="text">
                <p>FCFS (First-Come-First-Serve) is the easiest disk scheduling algorithm among all the scheduling
                    algorithms.
                    In the FCFS disk scheduling algorithm, each input/output request is served in the order in which the
                    requests arrive.
                    In this algorithm, starvation does not occur because FCFS address each request.

                </p>



              

                <h3>Advantages:</h3>
                <ul>

                    <li> First Come First Serve algorithm has a very simple logic, it executes the process requests one
                        by one in the sequence they arrive.</li>

                    <li>Thus, First Come First Serve is very simple and easy to understand and implement. </li>
                    </li>Thus, First Come First Serve is very simple and easy to understand and implement.</li>
                    <li>In FCFS eventually, each and every process gets a chance to execute, so no starvation occur.
                    </li>

                </ul>
                <h3>Disadvantages:</h3>
                <ul>

                </ul>

                <p>
                <ul>

                    <li>This scheduling algorithm is nonpreemptive, which means the process can’t be stopped in middle
                        of execution and will run it’s full course.</li>
                    <li>FCFS being a nonpreemptive scheduling algorithm, the short processes which are at the back of
                        the queue have to wait for the long process at the front to finish</li>
                    <li>The throughput of FCFS is not very efficient.</li>
                    <li>FCFS is implemented on small systems only where input-output efficiency is not of utmost
                        importance.</li>
                </ul>
                </p>




                <h3>Implementation: </h3>
                <ol>
                    <li> Input the processes along with their burst time (bt).</li>
                    <li> Find waiting time (wt) for all processes.</li>
                    <li> As first process that comes need not to wait so
                        waiting time for process 1 will be 0 i.e. wt[0] = 0.</li>
                    <li> Find waiting time for all other processes i.e. for
                        process i ->
                        wt[i] = bt[i-1] + wt[i-1] .</li>
                    <li> Find turnaround time = waiting_time + burst_time
                        for all processes.</li>
                    <li> Find average waiting time =
                        total_waiting_time / no_of_processes.</li>
                    <li> Similarly, find average turnaround time =
                        total_turn_around_time / no_of_processes.</li>

                </ol>

                <p>FCFS is the simplest disk scheduling algorithm. As the name suggests, this algorithm entertains
                    requests in the order they arrive in the disk queue. The algorithm looks very fair and there is no
                    starvation (all requests are serviced sequentially) but generally, it does not provide the fastest
                    service.</p>

                <h3>Algorithm: </h3>
                <ol>
                    <li> Let Request array represents an array storing indexes of tracks that have been requested in
                        ascending order of their time of arrival. ‘head’ is the position of disk head.</li>
                    <li> Let us one by one take the tracks in default order and calculate the absolute distance of the
                        track from the head.</li>
                    <li> Increment the total seek count with this distance.</li>
                    <li> Currently serviced track position now becomes the new head position.</li>
                    <li> Go to step 2 until all tracks in request array have not been serviced.</li>

                </ol>

                <h3>Example: </h3>
                <h4>Input: </h4>
                <p>Request sequence = {176, 79, 34, 60, 92, 11, 41, 114}</p>
                <p>Initial head position = 50</p>

                <h4>Output: </h4>
                <p>Total number of seek operations = 510</p>
                <p>Seek Sequence is</p>

                <div class="array">
                    <p class="numbers">176</p>
                    <p class="numbers">79</p>
                    <p class="numbers">34</p>
                    <p class="numbers">60</p>
                    <p class="numbers">92</p>
                    <p class="numbers">11</p>
                    <p class="numbers">41</p>
                    <p class="numbers">114</p>
                </div>
                <p>
                    The following chart shows the sequence in which requested tracks are serviced using FCFS.
                </p>


                <img src="./Graph.jpg" alt="">

                <p>Therefore, the total seek count is calculated as:</p>
                <p>= (176-50)+(176-79)+(79-34)+(60-34)+(92-60)+(92-11)+(41-11)+(114-41)</p>
                <p>= 510</p>

            </div>
        </div>
    </div>
</body>

</html>
